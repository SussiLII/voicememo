is our friend the for loop. What is the for loop, okay? The for loop is gonna look a little cryptic when you first see it. It's syntax or the way we write it looks like this in Python. writing literally verbatim before I can range with those spaces in there. And then inside parentheses, you have a count. That count is just a number. It is how many times you want to do something over and over. And the thing you want to do over and over is some set of instructions or statements. And the way we know what statements we're going to do over and over, lo and behold, is it's a block of code. If we indent back that, we know we are done with the body of that loop. Okay? So let me give you an example of what this looks like. Let's say we wanted to write the turn right command, not as turn left, turn left, turn left, but to do turn left three times. So what we would say is let's define the turn right function, which is... left, you can define it alternatively and say, for i in range 3, because we want to do something three times, turn left. Notice the turn left is indented another level in, because what's going on here is the first level of indentation says, this is Then we have for i in range, which is the loop. What's all the stuff inside the loop? It's term left, so that's indented another level. So what's actually going on is that term left is two tab stops in because it indicates that that term left is part of the loop, which is in turn part of the function. So any questions about that? But what this function will do to turn right is exactly the same as what you saw with just turn left, turn left, turn left. It will do whatever is in the body of the loop three times. You're like, okay, Baron, that's just one command. Can we do something more involved? Sure. Let's have Carol place a whole square full of beavers. So what we want to do is Carol's going to be in this little square. We want Carol to place a beaver on every corner of that square. And there's four corners on the square. And it turns out if Carol does something repetitive four times, we can actually place beepers on every corner. So what we're going to do is we're going to do this inside our main program. So notice the level of indenting. The first level of indenting says all of this stuff is inside of our main program. The stuff that's in our loop is the stuff that's indented another level inside the for loop. So we say the stuff that's inside the for loop is put beeper, move, and turn left. Let's see if this works. One thing that I would want to do is I would say let's take the code out for a spin. It's like we have an old school car. We're taking it out for a drive. These days it would be electric because it's got a robot. So what we're going to do is we're going to execute the code. What happens when we start our program? We come to main because that's where execution starts. So we say, okay, we start at main. What's the first command in main? It says... You're going to have a loop. You're going to do something four times because that's what I've specified in the range of the loop. Okay? Let's go through the first time, the loop the first time. So we come in to execute what's known as the body of the loop, which are all the statements inside the loop. And so we put a beeper. So notice what's going on here. Watch Carol. We put a beeper. We move. So Carol moves to the next corner. And then we turn left. Why did we turn left? Because we want to prepare Carol to be able to put down another beeper, move to another empty location, and get ready to do that again. If we didn't turn left, Carol would be facing the wall, and if we tried to put a beeper and then do another move, whammo, we would hit the wall, and that would be a bad time. So we do a turn left. Notice Carol is now facing to the north, or upward. And we go back through the loop. This is now what we refer to as iteration two, the second time through the loop. so we do the same body of the loop again sequentially we put a beeper we move and we turn left looks like harold's upside down but it's actually facing down to the west one more time third time through the loop put the beeper move turn left and final time through the loop for the fourth time through the loop put beeper move turn left rocking good time now we're done so notice we did the whole body of the loop four times we put a beeper on every corner in that little square And you might say, hey, Merriman, did this little turn left at the end, how come we did that turn left at the end? It's because here's the fancy way of saying it. We wanted the precondition for the loop to match the postcondition for the loop. What does that mean? It means the things that we wanted true before Carol started an iteration of loop, that's known as the precondition, we wanted those same things true after it did an iteration of the loop so we could do that loop over and over. And the idea here is when Carol started out, if we back all the way up, Carroll started out on a corner where there was no beeper and its front was clear. So what could we do? We could put a beeper, we could move, and then we want to get into a configuration where that same thing is true again. Notice when Carroll's facing upward, it's on a corner with no beeper and its front is clear. So the conditions that were true on the last round through the loop are true for the next round through the loop, and that means every time the loop executes, the conditions we expect to be true in the world will still be true, and the loop will kind of execute all the way through. So there's our friend before loop. Any questions about that? Please. I was just curious, so why do you have to include, like why do you have to put beeper each time? Isn't the beeper kind of like already placed and then it just moves to the next? No, because every corner Carol goes to, if there's not a beeper there, it has to put one down. Oh, I see. So every time we do a loop, every time we get to a new corner, we have to put a beeper because the previous beeper is on the last corner. It's not like, it might be sitting there sad going like, you left me behind. But Carol's like, yeah, I've got to go to the next corner. That's just like what I would put to you. And the beeper's sitting there with a tear in the top. If you've ever had the moment where you're sitting down looking at a beeper and you're tearing its eye, you know just how sad it can be. But don't be sad because Carol will always be in this world and all the beepers are her friends. Okay? You're like, really, Carol? Do you have to tell that whole story? I did. It just makes programming more fun. Have fun while you're programming. To be clear, the tentacle can hold some number of beepers in the beginning. Why does it care? It's already holding them. Yeah, so it has beepers in its back. And we'll tell you those kind of conditions when you write your program. Thank you. All right, so there's our friend, the four-loop. Let's cruise down, continue to cruise down the river. Next thing we have is our friend, the wild-loop. Another kind of loop, but we're going to do something over and over, but it's a little bit different than what we think about in terms of... Oh, my little... My timer... All right. The way the while loop works is you say while, and then some condition, and I'll tell you what conditions can be. That condition is either true or false about what's happening in Carol's world right now. If the condition is true, then it executes the body of the loop for all the statements that are inside the loop. Again, they're indented one level, so we know what's in the loop. And if the condition is false, we do not execute and I want to see how close the wall is, you can say, oh, try taking 10 steps over there. And I'd be like, but I don't know if it's 10 steps or not. So if I just move over and I'm like, one, two, I want to keep doing something until some condition I care about is true. Like I want to keep moving until I get to a place where my front is now blocked. There's no longer something in front of you. That's what this function does. It says move to the wall. I don't know how far away the wall is from you, but what I want you to do is check. Is your front clear? So inside the definition of move to wall is a while loop that says while your front is clear, the body of the loop, which is indented in another level, says move. So basically it says, is your front clear? If there's nothing in front of you, move. And if there's nothing in front of you, move again. And keep moving. Every time you move, check the condition of the loop again until eventually you get to the place where you say, move, is your front clear? No, there's a wall, and I stop. So I don't go one final time through the loop. When that condition becomes false, I stop. And I'll show you a more complicated example of this in just a second. You're like, what are the conditions I can check? These are all in chapter 10 of your course reader. There's a whole bunch of things. You can check if your front is clear. You can actually check your sides. You can see if your left or your right is clear. Because Carol has sort of arms that can check up immediately, is there a wall to my left or my right? But Carol cannot check its back. It can check to see, are there beepers present? So is there at least one beeper on the corner of the mat? It cannot know how many beepers, but it can check, is there at least one? Or do I have any beepers, like at least one beeper in my bag? Again, it can't determine the number, but it can determine, is there at least one beeper there, or are there no beepers in the bag? So you can see every test also has an opposite that you can check. and it can ask which way it's facing. Like, am I facing east, am I facing south, am I facing north? So if I wanted to face north and I didn't know which way Carol was facing, I could say, while not facing north, turn left. And so Carol will keep turning left, and when it gets to facing north, not facing north is no longer true, so it will stop. So that's an example of what I can do. Let me show you a more complicated example. Here's the task that we're going to do. Let's say there's some world. We don't know how big it is. That's the big thing here. We do not know how big this world is. But a before condition has carol on corner 1, 1 with no beepers in the world, but it has as many beepers as it wants in its bag. And over here, the place we want to get to is we want carol to lay down a row of beepers, one beeper on every corner until it gets to the end of the row. So how might we consider doing that? Any idea? How do we know that we've gotten to the end of the row? Uh-huh? Yeah, while your front is clear, you know you haven't gotten to the end of the row. So we're going to have a while loop. While front is clear. And what we're going to do is we're going to say, while my front is clear, here's an idea. Let me put a beeper down. So I put a beeper on the corner that I'm at, and let me move. Now I'm at a place that doesn't have a beeper. If my front is clear, let me put another beeper down and take another step. So let's see what this does. This seems like a reasonable approach. Notice that when we start with main, and then we have indented in one level is the while loop. The while loop has two commands in its body now, because both the put beeper and the move are indented in one level. Okay? So we check. Is your front clear? The very first time it comes to the loop, it checks the test. If the first time you come to the loop, you check the test and the test is false, it will not execute what's inside the loop. It will just skip over the loop and keep executing from there. Okay? So even on the very first time, you're never guaranteed everything in the loop happens, even the first time it checks the test. So it comes here. Is the front clear for Carol? All together. Is it clear? Yes. Yes. All right. So while our front is clear, we're going to say put deeper. So we put it deeper, and then we move. Okay? So Carol moves. Then we come back up. Uh-huh. Question? What does that affect the line? We're going to get there. Thank you, friends. You're already ahead of me. I love it when someone's so far ahead that they're like, I've already figured out my head. And that is a beautiful thing. And if you do that, please, by all means, think ahead. It is a lovely thing. And then we'll all get there together as well. So while my front is clear, I did this put beeper, and I didn't move until I'm on the next corner. I come back up to the top of my loop. Is my front still clear? Yes. So I put a beeper, and I move. Come back here to the top of the loop. Check if front is clear. Yes. I put a beeper and I move. And I come back up here. Is my front clear? No. I've now reached the end of the road. This is precisely the situation we pointed out. Thank you for doing that. Because guess what happens now? What happens when my front is no longer clear? Don't do anything. It doesn't execute the loop one last time. It says the front is no longer clear. You are done. Executes the loop. And there's nothing else to execute after loop. So it says you're done. And you're like, But Maron, this was not the intended effect. And you hate that whining noise. I hate that whining noise. I make the whining noise. I hate the whining noise. This is what in programming parlance we refer to as a bug, which is code that does not work properly. And the reason why the code is buggy is we don't have a final put beeper on this final corner. There's no beeper here on this final corner. So we did not lay down the road. So what do we need to do to solve this problem? What do you think? Yeah? After the while loop, we add a put beeper. Notice where the put beeper is, right? So at this point, the code is fixed. Notice the indenting. I still have a level of indentation for everything inside the main function. The level of indentation for the while loop shows you that only those first two commands, put beeper and move, are inside the while loop. command, put beepers outside the loop, which means those two instructions inside the loop will happen over and over. And when the loop is done, then we come to this final put beeper. That final put beeper is not part of the loop. It just gets executed after the loop is done. And we put down the final beeper. And lo and behold, we fix the problem. This is, in computer science, what we refer to as a fence post problem. And the reason why it's called a fence post problem, if you've ever built a fence, any of you ever built a fence? Yeah, a couple posts. It's a good time. You notice one of the things when you build a fence, if you put down one more post and gaps between the post and the fence. So you have, if your algorithm for building a fence or the way you approach building a fence is put a post and then put the connection, put a post and put the connection, when you got to the end of the fence, you would need one final post without a connection. So you do one final thing one extra time to make the fence work that's outside of your loop. Sometimes it's also referred to as an off-by-one bug or an off-by-one error. If you're sort of a music type, it's an oboe off-by-one error. If you're not a musical type, it's an off-by-one error. And the basic idea here for the for loop is the program is executing one line at a time. When you have a while loop, you check the condition for the while loop at the start of the code block and every time before you repeat the code block. If the condition becomes false in the middle of the loop, it does not check that. It checks the beginning of the loop. It will continue to execute all the statements, even if the condition for the loop becomes false while it's executing an iteration of the loop. And then it will, on the next round, check the condition of the loop before it executes it again. So it checks it at the start and before every time it repeats the loop. Any questions about that?